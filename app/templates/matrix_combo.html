{% extends "base.html" %}

{% block content %}

<script id="vertexShader" type="GLSL">
	precision mediump float;
	attribute vec2 a_position;
	attribute vec4 a_vert_color;
	varying vec4 v_frag_color;
	
	void main() {
	v_frag_color = a_vert_color;
	gl_Position = vec4(a_position,0.0,1.0);
	}
</script>

<script id="fragmentShader" type="GLSL">
	precision mediump float;
	varying vec4 v_frag_color;
	
	void main() {
	gl_FragColor = v_frag_color;
	}
</script>

<script>
	function main() {
		window.addEventListener("resize", pageResize, false);
		navbar = document.getElementsByClassName("navbar")[0];
		
		// Canvas div contains the canvas element that the matrices will be drawn to
		createCanvasDiv();
		// Equation div contains buttons to add new items to the current equation, as well as the equation itself
		createEquationDiv();
		// Resizes all elements of the page to fit the current display size
		pageResize();
		
		// Functions for handling all mouse events on the canvas
		mouseDown = false;
		canvas.onmousedown = mouseDown;
		canvas.onmouseup = mouseUp;
		canvas.onmousemove = mouseMove;
		
		// Both fundamental GLSL shaders that WebGl uses to render vertices to the canvas element
		// Vertex shader handles the corners of polygons being rendered to the canvas and then sends this data to the fragment shader
		vertexShader = createShader(gl.VERTEX_SHADER, document.getElementById("vertexShader").text);
		// Fragment shader takes vertex shader output and renders the pixels between each vertice to create a filled shape of specified color(s).
		fragmentShader = createShader(gl.FRAGMENT_SHADER, document.getElementById("fragmentShader").text);
		
		// WebGL shader program which links the vertex and fragment shaders, and allows them to be used by the GPU
		program = createProgram(vertexShader, fragmentShader);
		
		// An object for storing vertices
		vertexBufferObject = gl.createBuffer();
		// This links the VBO to the array buffer in the GPU
		gl.bindBuffer(gl.ARRAY_BUFFER, vertexBufferObject);
		
		// This tells the shader program what attributes to expect, what data types they will be, how many bytes long etc.
		prepareAttributes();
		
		// Add the axes to the list of vertices
		vertices = declareStaticVertices();
		
		//createPolygon([0, 0], 5, 0.2, [255/255, 255/255, 0/255, 255/255], false);
		
		// Begins the render loop
		requestAnimationFrame(render);
	}
	
	// Reizes all elements on page
	function pageResize() {
		resizeCanvas();
		changePageLayout();
		resizeTopRowButtons();
	}
	
	// Create a new div to wrap a html5 canvas with a WebGL context
	function createCanvasDiv() {
		canvas_div = document.createElement("div");
		canvas_div.id = "canvas_div";
		canvas_div.style.padding = "5vh 5vh 5vh 5vh";
		canvas_div.style.display = "block";
		canvas_div.style.float = "left";
		document.body.appendChild(canvas_div);
		
		canvas = document.createElement("canvas");
		canvas_div.appendChild(canvas);
		
		gl = canvas.getContext("webgl");
		
		// Make the canvas a square that fits the window
		canvas.style.borderStyle = "solid";
		canvas.style.borderColor = "black";
		canvas_border_thickness = 0;
		canvas.style.borderWidth = canvas_border_thickness;
	}
	
	// Create new div to hold the current matrix equation and the buttons used for editing the equation
	function createEquationDiv() {
		equation_div = document.createElement("div");
		equation_div.id = "equation_div";
		equation_div.style.padding = "5vh 5vh 5vh 5vh";
		equation_div.style.display = "block";
		document.body.appendChild(equation_div);
		
		// Create container div for top row buttons
		topRowButtonDiv = document.createElement("div");
		topRowButtonDiv.id = "topRowButtonDiv";
		topRowButtonDiv.style.padding = 0;
		topRowButtonDiv.style.marginBottom = "4vh";

		equation_div.appendChild(topRowButtonDiv);
		 
		// Used for calculating widths for the top row buttons
		topRowButtonCount = 0;

		// Create all buttons for adding new items
		addTopRowButton("scalarButton", "Add scalar", addScalar);
		addTopRowButton("matrixButton", "Add matrix", addMatrix);
		addTopRowButton("operatorButton", "Add operator	", null);
		
		// Create container div for all items e.g. scalars, matrices and operators
		itemDiv = document.createElement("div");
		itemDiv.id = "itemDiv";
		itemDiv.style.padding = 0;
		equation_div.appendChild(itemDiv);
		
		// Counts increase/decrease for every item added/removed from the equation
		matrixCount = 0;
		scalarCount = 0;
		operatorCount = 0;
	}
	
	// Makes the canvas a square shape that fits perfectly within the viewport
	function resizeCanvas() {
		var navbar_height = pxToFloat(window.getComputedStyle(navbar).height);
		var canvas_div_padding = pxToFloat(window.getComputedStyle(canvas_div).padding);
		
		// We use this instead of window.innerHeight because it prevents a bug on mobile
		// It prevents the whole page rearranging when the mobile URL bar hides during scrolling
		// Using the computed style, height gets the height of the window, ignoring the url bar.
		var window_height = pxToFloat(window.getComputedStyle(document.body)["height"]);
		
		// Page taller than wide (portrait orientation)
		if (window.innerHeight - navbar_height > window.innerWidth) {
			canvas.width = window.innerWidth - 2*canvas_div_padding - 2*canvas_border_thickness;
			canvas.height = canvas.width;
		}
		// Page wider than tall (landscape orientation)
		else {
			canvas.height = window_height - 2*canvas_div_padding - 2*canvas_border_thickness - navbar_height;
			//canvas.height = window.innerHeight - 2*canvas_div_padding - 2*canvas_border_thickness - navbar_height;
			canvas.width = canvas.height;
		}
		
		// Size the viewport according to the canvas size
		gl.viewport(0,0,canvas.width,canvas.height);
	}
	
	// This function also decides whether the canvas and equation divs will be side by stacked vertically
	function changePageLayout() {
		var canvas_div_padding = pxToFloat(window.getComputedStyle(canvas_div).padding);
		var equation_div_padding = pxToFloat(window.getComputedStyle(equation_div).padding);
		
		// Check whether equation_div should beside canvas_div, or underneath canvas_div
		// If the canvas (and its padding) is taking more than half of the horizontal screen space...
		if (canvas.width + 2*canvas_div_padding > 0.5*window.innerWidth) {
			console.log("underneath");
			equation_div.style.float = "left";
			equation_div.style.width = window.innerWidth - 2*equation_div_padding - 20;
		}
		else {
			console.log("beside");
			equation_div.style.float = "right";
			equation_div.style.width = window.innerWidth - canvas.width - 2*canvas_div_padding - 2*equation_div_padding - 20;
		}
	}
	
	// Recalculates sizes of top row buttons based on rest of page
	function resizeTopRowButtons() {
		var buttons = [document.getElementById("scalarButton"), document.getElementById("matrixButton"), document.getElementById("operatorButton")];
		
		var i = 0;
		while (i < buttons.length) {
			var button = buttons[i];
			button.style.width = pxToFloat(window.getComputedStyle(topRowButtonDiv)["width"])/topRowButtonCount - 2*pxToFloat(button.style.paddingLeft) - 2*pxToFloat(button.style.borderWidth);// - (window.innerWidth - document.body.clientWidth)/topRowButtonCount;
			i += 1;
		}
		
		var i = 0;
		while (i < buttons.length) {
			buttons[i].style.height = "auto";
			i+=1
		}

		var tallestHeight = 0;
		var i = 0;
		while (i < buttons.length) {
			var button = buttons[i];
			currentHeight = pxToFloat(window.getComputedStyle(button)["height"]);
			if (currentHeight > tallestHeight) {
				tallestHeight = currentHeight;
			}
			i += 1;
		}
		
		var i = 0;
		while (i < buttons.length) {
			var button = buttons[i];
			button.style.height = tallestHeight;
			i += 1;
		}
	}
	
	// Creates a new top row button e.g. add scalar
	function addTopRowButton(id, innerHTML, onclick) {
		var button = document.createElement("div");
		button.id = id;
		button.innerHTML = innerHTML;
		button.class = "button";
		
		button.style.borderWidth = 1;
		button.style.borderStyle = "solid";
		button.style.borderColor = "black";
		
		button.style.cursor = "pointer";
		button.style.textAlign = "center";
		button.style.verticalAlign = "top";
		button.style.display = "inline-block";
		
		button.style.padding = 0;
		button.style.paddingTop = "2vh";
		button.style.paddingBottom = "2vh";
		
		button.onclick = onclick;
		
		topRowButtonCount += 1;
		
		topRowButtonDiv.appendChild(button);
	}
	
	// Converts canvas values (pixels) to clipspace values (-1 to 1)
	function canvasYToClipspace(y) {
		var navbar_height = pxToFloat(window.getComputedStyle(navbar).height);
		var canvas_div_padding = pxToFloat(window.getComputedStyle(canvas_div).padding);
		
		return (canvas.height - y + canvas_div_padding + canvas_border_thickness + navbar_height)/canvas.height*2 - 1;
	}
	
	function canvasXToClipspace(x) {
		var navbar_height = pxToFloat(window.getComputedStyle(navbar).height);
		var canvas_div_padding = pxToFloat(window.getComputedStyle(canvas_div).padding);
		
		return (x - canvas_div_padding - canvas_border_thickness)/canvas.height*2 - 1;
	}
	
	
	// Handles mouse events
	function mouseDown(event) {
		mouseDownX = event.clientX;
		mouseDownY = event.clientY;
		mouseDown = true;
	}
	
	function mouseUp(event) {
		mouseX = canvasXToClipspace(event.clientX);
		mouseY = canvasYToClipspace(event.clientY);
		mouseDown = false;
		createPolygon([mouseX, mouseY], 5, 0.04, [255/255, 0/255, 0/255, 255/255], false);
	}
	
	function mouseMove(event) {
		mouseX = canvasXToClipspace(event.clientX);
		mouseY = canvasYToClipspace(event.clientY);
	}
	
	// Create a new shader of the specified type
	function createShader(type, source) {
		var shader = gl.createShader(type);
		
		gl.shaderSource(shader, source);
		gl.compileShader(shader);
		
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			console.error("Shader failed to compile", gl.getShaderInfoLog(shader));
			return false;
		}
		
		return shader;
	}
	
	// Create a program using a vertex and fragment shader
	function createProgram(vertexShader, fragmentShader) {
		var program = gl.createProgram();
		
		gl.attachShader(program, vertexShader);
		gl.attachShader(program, fragmentShader);
		
		gl.linkProgram(program);
		
		return program;
	}
	
	// Prepare the attributes in the program to be interfaced by the rest of the program
	function prepareAttributes() {
		positionElements = 2; // 2 position elements per vertice (x, y)
		colorElements = 4; // 4 color elements per vertice (red, green, blue, alpha)
		totalElements = positionElements + colorElements; // The total number of elements per vertice (in this case 2 + 4)
		
		positionAttributeLocation = gl.getAttribLocation(program, "a_position");
		gl.vertexAttribPointer(positionAttributeLocation, positionElements, gl.FLOAT, gl.FALSE, totalElements * Float32Array.BYTES_PER_ELEMENT, 0);
		
		colorAttributeLocation = gl.getAttribLocation(program, "a_vert_color");
		gl.vertexAttribPointer(colorAttributeLocation, colorElements, gl.FLOAT, gl.FALSE, totalElements * Float32Array.BYTES_PER_ELEMENT, positionElements * Float32Array.BYTES_PER_ELEMENT);
		
		gl.enableVertexAttribArray(positionAttributeLocation);
		gl.enableVertexAttribArray(colorAttributeLocation);
	}
	
	// Rotates a 2D point about 0,0 by the specified angle
	function rotateVertice(vertice, angle) {
		var rotatedVertice = [];
		rotatedVertice[0] = (vertice[0]) * Math.cos(angle) - (vertice[1]) * Math.sin(angle);
		rotatedVertice[1] = (vertice[0]) * Math.sin(angle) + (vertice[1]) * Math.cos(angle);
		return rotatedVertice;
	}
	
	// Translates a 2D point by a certain amount horizontally and vertically
	function translateVertice(vertice, translation) {
		vertice[0] += translation[0];
		vertice[1] += translation[1];
		return vertice;
	}
	
	// Keeps drawing triangles until we run out of vertices
	function drawTriangles(vertices) {
		if (vertices.length >= totalElements*3) {
			gl.bindBuffer(gl.ARRAY_BUFFER, vertexBufferObject);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
			gl.drawArrays(gl.TRIANGLES, 0, vertices.length/totalElements);
		}
	}
	
	// Generates vertices for any polygon
	function createPolygon(origin, sides, radius, color, constrainToAxes) {
		// Makes sure that you cannot draw outside the axes
		if (constrainToAxes) {
			origin[0] *= axisWidth;
			origin[1] *= axisWidth;
		}
		
		var centralAngle = 2*Math.PI/sides;
		
		var s = 0;
		while (s < sides) {
			// Stores the current triangular fragment of the polygon before it is added to the vertices
			var currentTriangle = [];

			currentTriangle[0] = [0, 0];
			currentTriangle[1] = rotateVertice([0, radius], centralAngle/2);
			currentTriangle[2] = rotateVertice([0, radius], -centralAngle/2);

			var t = 0;
			while (t < 3) {
				currentTriangle[t] = rotateVertice(currentTriangle[t], centralAngle*s);
				currentTriangle[t] = translateVertice(currentTriangle[t], [origin[0],origin[1]]);
				currentTriangle[t] = currentTriangle[t].concat(color);
				vertices = vertices.concat(currentTriangle[t]);
				t += 1
			}
			s += 1
		}
	}
	
	// Declares all the static vertices that will be drawn
	function declareStaticVertices() {
		vertices = [];
	
		// Properties of the axis lines (axisWidth is global because it is used to scale polygons within the axes)
		var axisThickness = 0.01;
		axisWidth = 0.9;
		var axisColor = [0/255, 0/255, 0/255, 255/255];
		
		// X axis made of two triangles
		vertices = vertices.concat([-axisWidth,  axisThickness]).concat(axisColor);
		vertices = vertices.concat([-axisWidth, -axisThickness]).concat(axisColor);
		vertices = vertices.concat([ axisWidth,  axisThickness]).concat(axisColor);
		
		vertices = vertices.concat([ axisWidth,  axisThickness]).concat(axisColor);
		vertices = vertices.concat([ axisWidth, -axisThickness]).concat(axisColor);
		vertices = vertices.concat([-axisWidth, -axisThickness]).concat(axisColor);
		
		// Y axis made of two triangles
		vertices = vertices.concat([ axisThickness, -axisWidth]).concat(axisColor);
		vertices = vertices.concat([-axisThickness, -axisWidth]).concat(axisColor);
		vertices = vertices.concat([ axisThickness,  axisWidth]).concat(axisColor);
		
		vertices = vertices.concat([ axisThickness,  axisWidth]).concat(axisColor);
		vertices = vertices.concat([-axisThickness,  axisWidth]).concat(axisColor);
		vertices = vertices.concat([-axisThickness, -axisWidth]).concat(axisColor);
		
		return vertices;
	}
	
	// Render loop called every frame update
	function render() {
		gl.useProgram(program);
		
		// Clears the screen and temporary buffers
		//gl.clearColor(255/255, 255/255, 255/255, 255/255);
		gl.clearColor(242/255, 242/255, 242/255, 255/255);
		gl.clear(gl.COLOR_BUFFER_BIT);
		
		// Draws the vertices declared in main
		drawTriangles(vertices);
		
		// Render the next frame
		requestAnimationFrame(render);
	}
	
	main();
	
// ------------------------------------------------------
// DIVIDER BETWEEN THE FIRST SCRIPT AND THE SECOND SCRIPT
// ------------------------------------------------------

	// Creates an empty item that can become a scalar, matrix or operator
	function createEmptyItem(itemClass, itemCount) {
		var itemWrapper = document.createElement("div");
		itemWrapper.class = itemClass;
		itemWrapper.id = itemCount;
		itemWrapper.style.display = "grid";
		itemWrapper.style.gridTemplateColumns = "repeat(11, 1fr)";
		itemWrapper.style.gridTemplateRows = "repeat(9, 1fr)"; 
		itemWrapper.style.background = "#d6d6d6";
		itemWrapper.style.padding = 0;
		itemWrapper.style.marginBottom = "2vh";
		
		var itemSidebar = document.createElement("div");
		itemSidebar.class = "itemSidebar";
		itemSidebar.style.gridColumnStart = 1;
		itemSidebar.style.gridColumnEnd = 3;
		itemSidebar.style.gridRowStart = 1;
		itemSidebar.style.gridRowEnd = 10;
		itemSidebar.style.background = "#cccccc";
		
		var itemName = document.createElement("div");
		itemName.class = "itemName";
		itemName.style.gridColumnStart = 1;
		itemName.style.gridColumnEnd = 3;
		itemName.style.gridRowStart = 1;
		itemName.style.gridRowEnd = 2;
		itemName.style.background = "#aaaaaa";
		itemName.style.padding = 0;
		itemName.style.textAlign = "center";
		itemName.innerHTML = itemWrapper.class + itemWrapper.id;
		
		var itemMoveUpIcon = document.createElement("img");
		itemMoveUpIcon.class = "itemMoveUpIcon";
		itemMoveUpIcon.src = "static/moveup.png";
		itemMoveUpIcon.style.cursor = "pointer";
		itemMoveUpIcon.style.imageRendering = "pixelated";
		itemMoveUpIcon.style.height = "100%";
		itemMoveUpIcon.style.margin = "0 auto";
		itemMoveUpIcon.style.gridColumnStart = 2;
		itemMoveUpIcon.style.gridColumnEnd = 3;
		itemMoveUpIcon.style.gridRowStart = 4;
		itemMoveUpIcon.style.gridRowEnd = 5;
		itemMoveUpIcon.onclick = moveItemUp;
		
		var itemDeleteIcon = document.createElement("img");
		itemDeleteIcon.class = "itemDeleteIcon";
		itemDeleteIcon.src = "static/delete.png";
		itemDeleteIcon.style.cursor = "pointer";
		itemDeleteIcon.style.imageRendering = "pixelated";
		itemDeleteIcon.style.height = "100%";
		itemDeleteIcon.style.margin = "0 auto";
		itemDeleteIcon.style.gridColumnStart = 2;
		itemDeleteIcon.style.gridColumnEnd = 3;
		itemDeleteIcon.style.gridRowStart = 6;
		itemDeleteIcon.style.gridRowEnd = 7;
		itemDeleteIcon.onclick = deleteItem;
		
		var itemMoveDownIcon = document.createElement("img");
		itemMoveDownIcon.class = "itemMoveDownIcon";
		itemMoveDownIcon.src = "static/movedown.png";
		itemMoveDownIcon.style.cursor = "pointer";
		itemMoveDownIcon.style.imageRendering = "pixelated";
		itemMoveDownIcon.style.height = "100%";
		itemMoveDownIcon.style.margin = "0 auto";
		itemMoveDownIcon.style.gridColumnStart = 2;
		itemMoveDownIcon.style.gridColumnEnd = 3;
		itemMoveDownIcon.style.gridRowStart = 8;
		itemMoveDownIcon.style.gridRowEnd = 9;
		itemMoveDownIcon.onclick = moveItemDown;

		itemWrapper.appendChild(itemSidebar);
		itemWrapper.appendChild(itemName);
		itemWrapper.appendChild(itemMoveUpIcon);
		itemWrapper.appendChild(itemDeleteIcon);
		itemWrapper.appendChild(itemMoveDownIcon);
		//itemWrapper.appendChild(itemMoveDownIcon);
		
		return itemWrapper;
	}

	// Creates a scalar item
	function addScalar() {
		scalarCount += 1;
		var scalarWrapper = createEmptyItem("scalar", scalarCount);
		
		var scalarTextbox = document.createElement("input");
		scalarTextbox.class = "scalarTextbox";
		scalarTextbox.style.boxSizing = "border-box";
		scalarTextbox.style.width = "100%";
		scalarTextbox.style.gridColumnStart = 4;
		scalarTextbox.style.gridColumnEnd = 5;
		scalarTextbox.style.gridRowStart = 2;
		scalarTextbox.style.gridRowEnd = 3;
		scalarTextbox.style.textAlign = "center";
		scalarTextbox.type = "text";
		
		scalarWrapper.appendChild(scalarTextbox);
		
		itemDiv.appendChild(scalarWrapper);
		
		resizeTopRowButtons();
	}

	// Creates a matrix item
	function addMatrix() {
		matrixCount += 1;
		var matrixWrapper = createEmptyItem("matrix", matrixCount);
		
		var r = 0;
		while (r < 7) {
			var c = 0;
			while (c < 7) {
				var matrixElementTextbox = document.createElement("input");
				matrixElementTextbox.class = "matrixElementTextbox";
				matrixElementTextbox.style.boxSizing = "border-box";
				matrixElementTextbox.style.width = "100%";
				matrixElementTextbox.style.textAlign = "center";
				matrixElementTextbox.type = "text";
				
				matrixElementTextbox.style.gridColumnStart = 4+c;
				matrixElementTextbox.style.gridColumnEnd = 5+c;
				matrixElementTextbox.style.gridRowStart = 2+r;
				matrixElementTextbox.style.gridRowEnd = 3+r;
				
				matrixWrapper.appendChild(matrixElementTextbox);
				
				// Hide any rows or elements so only a 2x2 matrix shows
				if (r > 1 || c > 1) {
					matrixWrapper.lastChild.style.visibility = "hidden";
				}
				c += 1;
			}
			r += 1;
		}
		
		matrixWrapper.setAttribute("rows", 2);
		matrixWrapper.setAttribute("columns", 2);
		
		var addMatrixRowIcon = document.createElement("img");
		addMatrixRowIcon.class = "addMatrixRowIcon";
		addMatrixRowIcon.src = "static/add.png";
		addMatrixRowIcon.style.cursor = "pointer";
		addMatrixRowIcon.style.imageRendering = "pixelated";
		addMatrixRowIcon.style.height = "100%";
		addMatrixRowIcon.style.margin = "0 auto";
		addMatrixRowIcon.style.gridColumnStart = 4;
		addMatrixRowIcon.style.gridColumnEnd = 5;
		addMatrixRowIcon.style.gridRowStart = 9;
		addMatrixRowIcon.style.gridRowEnd = 10;
		addMatrixRowIcon.onclick = addMatrixRow;
		
		var removeMatrixRowIcon = document.createElement("img");
		removeMatrixRowIcon.class = "removeMatrixRowIcon";
		removeMatrixRowIcon.src = "static/remove.png";
		removeMatrixRowIcon.style.cursor = "pointer";
		removeMatrixRowIcon.style.imageRendering = "pixelated";
		removeMatrixRowIcon.style.height = "100%";
		removeMatrixRowIcon.style.margin = "0 auto";
		removeMatrixRowIcon.style.gridColumnStart = 5;
		removeMatrixRowIcon.style.gridColumnEnd = 6;
		removeMatrixRowIcon.style.gridRowStart = 9;
		removeMatrixRowIcon.style.gridRowEnd = 10;
		removeMatrixRowIcon.onclick = removeMatrixRow;
		
		var addMatrixColumnIcon = document.createElement("img");
		addMatrixColumnIcon.class = "addMatrixColumnIcon";
		addMatrixColumnIcon.src = "static/add.png";
		addMatrixColumnIcon.style.cursor = "pointer";
		addMatrixColumnIcon.style.imageRendering = "pixelated";
		addMatrixColumnIcon.style.height = "100%";
		addMatrixColumnIcon.style.margin = "0 auto";
		addMatrixColumnIcon.style.gridColumnStart = 11;
		addMatrixColumnIcon.style.gridColumnEnd = 12;
		addMatrixColumnIcon.style.gridRowStart = 2;
		addMatrixColumnIcon.style.gridRowEnd = 3;
		addMatrixColumnIcon.onclick = addMatrixColumn;
		
		var removeMatrixColumnIcon = document.createElement("img");
		removeMatrixColumnIcon.class = "removeMatrixColumnIcon";
		removeMatrixColumnIcon.src = "static/remove.png";
		removeMatrixColumnIcon.style.cursor = "pointer";
		removeMatrixColumnIcon.style.imageRendering = "pixelated";
		removeMatrixColumnIcon.style.height = "100%";
		removeMatrixColumnIcon.style.margin = "0 auto";
		removeMatrixColumnIcon.style.gridColumnStart = 11;
		removeMatrixColumnIcon.style.gridColumnEnd = 12;
		removeMatrixColumnIcon.style.gridRowStart = 3;
		removeMatrixColumnIcon.style.gridRowEnd = 4;
		removeMatrixColumnIcon.onclick = removeMatrixColumn;
		
		matrixWrapper.appendChild(addMatrixRowIcon);
		matrixWrapper.appendChild(removeMatrixRowIcon);
		matrixWrapper.appendChild(addMatrixColumnIcon);
		matrixWrapper.appendChild(removeMatrixColumnIcon);
		itemDiv.appendChild(matrixWrapper);
		
		resizeTopRowButtons();
	}

	function addMatrixRow() {
		var matrixWrapper = event["path"][1];
		var rows = parseInt(matrixWrapper.getAttribute("rows"));
		var columns = parseInt(matrixWrapper.getAttribute("columns"));

		if (rows < 7) {
			var c = 0;
			while (c < columns) {
				elementNumber = 7*rows + c + 5
				matrixWrapper.children[elementNumber].style.visibility = "";
				c += 1;
			}
			matrixWrapper.setAttribute("rows", rows+1)
		}
	}

	function removeMatrixRow() {
		var matrixWrapper = event["path"][1];
		var rows = parseInt(matrixWrapper.getAttribute("rows"));
		var columns = parseInt(matrixWrapper.getAttribute("columns"));
		
		if (rows > 1) {
			var c = 0;
			while (c < columns) {
				elementNumber = 7*(rows-1) + c + 5
				matrixWrapper.children[elementNumber].style.visibility = "hidden";
				c += 1;
			}
			matrixWrapper.setAttribute("rows", rows-1)
		}
	}

	function addMatrixColumn() {
		var matrixWrapper = event["path"][1];
		var rows = parseInt(matrixWrapper.getAttribute("rows"));
		var columns = parseInt(matrixWrapper.getAttribute("columns"));
		
		if (columns < 7) {
			var r = 0;
			while (r < rows) {
				elementNumber = 7*r + columns + 5
				matrixWrapper.children[elementNumber].style.visibility = "";
				r += 1;
			}
			matrixWrapper.setAttribute("columns", columns+1)
		}
	}

	function removeMatrixColumn() {
		var matrixWrapper = event["path"][1];
		var rows = parseInt(matrixWrapper.getAttribute("rows"));
		var columns = parseInt(matrixWrapper.getAttribute("columns"));
		
		if (columns > 1) {
			var r = 0;
			while (r < rows) {
				elementNumber = 7*r + (columns-1) + 5
				matrixWrapper.children[elementNumber].style.visibility = "hidden";
				r += 1;
			}
			matrixWrapper.setAttribute("columns", columns-1);
		}
	}

	function deleteItem(event) {
		// Gets parent element of the delete icon that was clicked
		var item = event["path"][1];
		
		// Changes id, name and count so that each item is still in order
		var i = 0;
		while (i < itemDiv.children.length) {
			// Only change item ids of items with the same class
			if (itemDiv.children[i].class == item.class) {
				if (parseInt(itemDiv.children[i].id) > parseInt(item.id)) {
					// Change id
					itemDiv.children[i].id = parseInt(itemDiv.children[i].id) - 1;
					// Change the name that is displayed
					itemDiv.children[i].children[1].innerHTML = itemDiv.children[i].class + itemDiv.children[i].id;
				}
			}
			i += 1;
		}
		
		if (item.class == "scalar") {
			scalarCount -= 1;
		}
		else if (item.class == "matrix") {
			matrixCount -= 1;
		}
		else {
			operatorCount -= 1;
		}
		
		item.parentNode.removeChild(item);
	}

	function moveItemUp(event) {
		var item = event["path"][0].parentNode;
		var previousItem = item.previousSibling;
		
		if (previousItem != null) {
			var parent = item.parentNode;
			
			parent.removeChild(item);
			parent.insertBefore(item, previousItem);
			
			// Swaps id's back if items are both of the same class (e.g. both scalars)
			if (previousItem.class == item.class) {
				var tempId = item.id;
				item.id = previousItem.id;
				previousItem.id = tempId;

				item.children[1].innerHTML = item.class + item.id;
				previousItem.children[1].innerHTML = previousItem.class + previousItem.id;
			}
		}
	}

	function moveItemDown(event) {
		var item = event["path"][0].parentNode;
		var nextItem = item.nextSibling;
		
		if (nextItem != null) {
			var parent = item.parentNode;
			
			parent.removeChild(item);
			
			// If removing the item before last, it must be re-inserted as the last item
			// Because it is the item before last, nextItem.nextSibling will be null meaning we have to use parent.appendChild instead of parent.insertBefore
			if (nextItem.nextSibling == null) {
				parent.appendChild(item);
			}
			else {
				parent.insertBefore(item, nextItem.nextSibling);
			}
			
			// Swaps id's back if items are both of the same class (e.g. both scalars)
			if (nextItem.class == item.class) {
				var tempId = item.id;
				item.id = nextItem.id;
				nextItem.id = tempId;

				item.children[1].innerHTML = item.class + item.id;
				nextItem.children[1].innerHTML = nextItem.class + nextItem.id;
			}
		}
	}
</script>

{% endblock %}