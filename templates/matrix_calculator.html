{% extends "templates\\base.html" %}

{% block content %}

<!-- Script that handles the way that the page is displayed e.g. orientation and sizes -->
<script type="text/javascript" src="scripts/matrix_calculator_layout.js"></script>

<!-- Script that handles drawing to the canvas using WebGL -->
<script type="text/javascript" src="scripts/matrix_calculator_canvas.js"></script>

<!-- The GLSL vertex shader script for use in WebGL -->
<script id="vertexShader" type="text/glsl">
	precision mediump float;
	attribute vec2 a_position;
	attribute vec4 a_vert_color;
	varying vec4 v_frag_color;
	
	void main() {
		v_frag_color = a_vert_color;
		gl_Position = vec4(a_position,0.0,1.0);
	}
</script>

<!-- The GLSL fragment shader script for use in WebGL -->
<script id="fragmentShader" type="text/glsl">
	precision mediump float;
	varying vec4 v_frag_color;
	
	void main() {
		gl_FragColor = v_frag_color;
	}
</script>

<!-- Script that handles the building of matrix equations using matrix, scalar and operator items -->
<script type="text/javascript" src="scripts/matrix_calculator_equation_builder.js"></script>

<!-- Script that handles the parsing and solving of the equations the user has inputted -->
<!--<script type="text/javascript" src="scripts/matrix_calculator_equation_solver.js"></script>-->

<script type="text/javascript">
	window.addEventListener("resize", matrix_calculator_layout.resizePage, false);
	matrix_calculator_layout.createMainDiv();
	matrix_calculator_layout.createCanvasDiv();
	matrix_calculator_layout.createEquationDiv();
	matrix_calculator_canvas.registerMouseEvents();
	matrix_calculator_canvas.setupWebGL();
	matrix_calculator_layout.resizePage();
	requestAnimationFrame(matrix_calculator_canvas.render);
</script>

<!--
<script type="text/javascript">
	window.addEventListener("resize", resizePage, false);
	navbar = document.getElementById("navbar");
	
	// Creates a main wrapper div for all elements
	createMainDiv();
	// Canvas div contains the canvas element that the matrices will be drawn to
	createCanvasDiv();
	// Equation div contains buttons to add new items to the current equation, as well as the equation itself
	createEquationDiv();
	// Resizes all elements of the page to fit the current display size
	window.setTimeout(resizePage, 1);
	//resizePage();
	// Functions for handling all mouse events on the canvas
	mouseDown = false;
	canvas.onmousedown = mouseDown;
	canvas.onmouseup = mouseUp;
	canvas.onmousemove = mouseMove;
	
	// Both fundamental GLSL shaders that WebGl uses to render vertices to the canvas element
	// Vertex shader handles the corners of polygons being rendered to the canvas and then sends this data to the fragment shader
	vertexShader = createShader(gl.VERTEX_SHADER, document.getElementById("vertexShader").text);
	// Fragment shader takes vertex shader output and renders the pixels between each vertice to create a filled shape of specified color(s).
	fragmentShader = createShader(gl.FRAGMENT_SHADER, document.getElementById("fragmentShader").text);
	
	// WebGL shader program which links the vertex and fragment shaders, and allows them to be used by the GPU
	program = createProgram(vertexShader, fragmentShader);
	
	// An object for storing vertices
	vertexBufferObject = gl.createBuffer();
	// This links the VBO to the array buffer in the GPU
	gl.bindBuffer(gl.ARRAY_BUFFER, vertexBufferObject);
	
	// This tells the shader program what attributes to expect, what data types they will be, how many bytes long etc.
	prepareAttributes();
	
	// Add the axes to the list of vertices
	vertices = declareStaticVertices();
	
	//createPolygon([0, 0], 5, 0.2, [255/255, 255/255, 0/255, 255/255], false);
	
	// Begins the render loop
	requestAnimationFrame(render);
</script>
-->
{% endblock %}